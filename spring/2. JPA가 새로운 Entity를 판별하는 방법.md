<h1 id=0>0️⃣목차</h1>

> 
1. [스프링 데이터 JPA의 새로운 엔티티 판단](#1)
2. [판단 방법](#2)
3. [결론](#3)

---

<h1 id=1>1️⃣ 새로운 Entity 여부 판단 이유</h1>

`Spring Data JPA`는 `ORM` 기술을 활용해 데이터베이스와 객체 간의 매핑을 대신 수행한다.
이때 엔티티 객체가 새로 생성된 것인지, 기존에 DB에 저장된 데이터(객체)인지 판단해야 한다.

> 🤔 왜 새로운 Entity 여부를 판단해야 하나?

**가장 큰 이유는 `insert`와 `update`를 구분하기 위함이다.**
또, 영속성 컨텍스트는 객체와 DB 데이터 간 동기화를 관리하는데, 이때 해당 객체가 이미 영속 상태인지 아닌지 혹은 ID가 존재하는지 없는지를 판단해야 한다.

---

<h1 id=2>2️⃣ 판단 방법</h1>

새로운 Entity인지 여부는 `JpaEntityInformation` 의 `isNew(T entity)` 에 의해 판단된다.
별다른 설정이 없으면 JpaEntityInformation의 구현체 중 `JpaMetamodelEntityInformation` 클래스가 동작한다.

`@Version` 이 사용된 필드가 없으면 `AbstractEntityInformation`의 `isNew()`를 호출한다.

```java
@Override
public boolean isNew(T entity){
	if(versionAttribute.isEmpty() || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive)
    	return super.isNew(entity);
    }
    
    BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);

    return versionAttribute.map(it -> wrapper.getPropertyValue(it.getName()) == null).orElse(true);
}
```

### ✅ 정리
간단히 말하면, 스프링 데이터 JPA가 새로운 엔티티를 식별하는 방법은 `식별자`를 통해 결정된다.

#### ✅식별자가 null인 경우
- 데이터베이스에 저장되지 않은 새로운 엔티티로 간주된다.

#### ✅식별자 값이 존재하는 경우
- 데이터베이스에 저장된 적이 있는 엔티티로 간주된다.

따라서 `JpaEntityInformation`의 `isNew()` 메소드는 엔티티의 식별자가 null인지를 확인하여 새로운 엔티티인지 여부를 판단한다.


---

<h1 id=3>3️⃣ 결론</h1>
JpaRepository 인터페이스를 상속받으면 별다른 설정이 없으면 스프링이 프록시로 SimpleJpaRepository 클래스를 주입한다.

이때 `save()` 메서드에서 `isNew()`를 사용하여 엔티티를 `persist` 할 지, `merge` 할 지를 결정한다.

만약 ID를 직접 지정하는 경우 식별자 값이 null이 아니므로 merge를 수행한다.

`mereg` 는 엔티티가 영속성 컨텍스트에 존재하는지 확인하고, 그것을 가져와 병합한다.
이 과정에서 두 번의 쿼리(SELECT, INSERT)가 발생하기 때문에 성능상 비효율적이다.

이러한 비효율 쿼리를 최적화 하기 위해 스프링 데이터 JPA가 어떻게 새로운 엔티티 여부를 판단하는지 인식하고 있어야, EntityManager를 직접 주입받아 `persist`를 호출함으로써 해결할 수 있다.
