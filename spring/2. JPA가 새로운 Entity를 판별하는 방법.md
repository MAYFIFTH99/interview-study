<h1 id=0>0️⃣목차</h1>

> 
1. [스프링 데이터 JPA의 새로운 엔티티 판단](#1)
2. [판단 방법](#2)
3. [결론](#3)

---

<h1 id=1>1️⃣ 새로운 Entity 여부 판단 이유</h1>

`Spring Data JPA`는 `ORM` 기술을 활용해 데이터베이스와 객체 간의 매핑을 대신 수행한다.
이때 엔티티 객체가 새로 생성된 것인지, 기존에 DB에 저장된 데이터(객체)인지 판단해야 한다.

> 🤔 왜 새로운 Entity 여부를 판단해야 하나?

**가장 큰 이유는 `insert`와 `update`를 구분하기 위함이다.**

`SimpleJpaRepository`의 `save()` 메서드에서 `isNew()`를 사용하여 `persist`를 수행할지, `merge`를 수행할지 결정한다.

만약 ID를 직접 지정해주는 경우에는 신규 entity라고 판단하지 않기 때문에 `persist`가 아닌 `merge` 과정이 일어난다.

이는 해당 엔티티가 신규임에도 불구하고 DB를 조회하는 과정을 거치기 때문에 두 번의 쿼리가 발생한다.

이러한 성능 저하 문제를 최적화 하기 위해 JPA가 어떻게 새로운 엔티티를 식별하는지 알고 있어야 한다.


---

<h1 id=2>2️⃣ 판단 방법</h1>

새로운 Entity인지 여부는 `JpaEntityInformation` 의 `isNew(T entity)` 에 의해 판단된다.
별다른 설정이 없으면 JpaEntityInformation의 구현체 중 `JpaMetamodelEntityInformation` 클래스가 동작한다.

`@Version`이 사용된 필드가 없거나 `@Version`이 사용된 필드가 `primitive` 타입이면 `AbstractEntityInformation`의 `isNew()` 메서드를 호출하고, `wrapper` 타입이면 `null` 여부로 확인한다.

```java
@Override
public boolean isNew(T entity){
	if(versionAttribute.isEmpty() || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive)
    	return super.isNew(entity);
    }
    
    BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);

    return versionAttribute.map(it -> wrapper.getPropertyValue(it.getName()) == null).orElse(true);
}
```

> `@Version`이 없는 경우

`@Version`이 사용된 필드가 없어서 `AbstractInformationEntity` 클래스가 동작하면 `@Id` 어노테이션을 사용한 필드를 확인해서 `primitive` 타입이 아니라면 `null` 여부를, `Number`의 하위 타입이면 `0` 인지 여부를 확인한다.

`@GeneratedValue` 어노테이션으로 키 생성 전략을 사용하면 DB에 저장 시 ID가 자동 할당된다.

따라서 데이터베이스에 저장되기 전에 메모리에서 생성된 객체는 ID가 비어있기 때문에 `isNew()` 결과가 `true`가 되어 새로운 엔티티로 판단한다.

> 그럼 직접 ID를 할당하는 경우는 어떻게 동작할까?

키 생성 전략을 사용하지 않고 직접 ID를 할당하는 경우에는 새로운 엔티티로 간주되지 않는다.
이 때는 엔티티에서 `Persistable<T>` 인터페이스를 구현해서 `JpaMetamodelInformation` 클래스가 아닌 `JpaPersistableEntityInformation`의 `isNew()` 가 동작하도록 구현해야 한다.

```java
public class JpaPersistableEntityInformation<T extends Persistable<ID, ID> 
        extends JpaMetamodelEntityInformation<T, ID> {

    public JpaPersistableEntityInformation(Class<T> domainClass, Metamodel metamodel, 
            PersistenceUnitUtil persistenceUnitUtil) {
        super(domainClass, metamodel, persistenceUnitUtil);
    }

    @Override
    public boolean isNew(T entity) {
        return entity.isNew();
    }

    @Nullable
    @Override
    public ID getId(T entity) {
        return entity.getId();
    }
}
```

### ✅ 정리
간단히 말하면, 스프링 데이터 JPA가 새로운 엔티티를 식별하는 방법은 `식별자`를 통해 결정된다.

#### ✅식별자가 null인 경우
- 데이터베이스에 저장되지 않은 새로운 엔티티로 간주된다.

#### ✅식별자 값이 존재하는 경우
- 데이터베이스에 저장된 적이 있는 엔티티로 간주된다.

따라서 `JpaEntityInformation`의 `isNew()` 메소드는 엔티티의 식별자가 null인지를 확인하여 새로운 엔티티인지 여부를 판단한다.


---

<h1 id=3>3️⃣ 결론</h1>
JpaRepository 인터페이스를 상속받으면 별다른 설정이 없으면 스프링이 프록시로 SimpleJpaRepository 클래스를 주입한다.

이때 `save()` 메서드에서 `isNew()`를 사용하여 엔티티를 `persist` 할 지, `merge` 할 지를 결정한다.

만약 ID를 직접 지정하는 경우 식별자 값이 null이 아니므로 merge를 수행한다.

`mereg` 는 엔티티가 영속성 컨텍스트에 존재하는지 확인하고, 그것을 가져와 병합한다.
이 과정에서 두 번의 쿼리(SELECT, INSERT)가 발생하기 때문에 성능상 비효율적이다.

이러한 비효율 쿼리를 최적화 하기 위해 스프링 데이터 JPA가 어떻게 새로운 엔티티 여부를 판단하는지 인식하고 있어야, EntityManager를 직접 주입받아 `persist`를 호출함으로써 해결할 수 있다.
