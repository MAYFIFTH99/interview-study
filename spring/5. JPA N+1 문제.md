<h1 id=0>0️⃣ 목차</h1>

> 
1. [N+1 문제란?](#1)
2. [즉시로딩](#2)
3. [지연로딩](#3)
4. [fetch join](#4)
5. [@EntityGraph](#5)
6. [Pagination](#6)
7. [Collection fetch join](#7)
8. [정리](#8)

---

<h1 id=1>1️⃣ N+1 문제란?</h1>

JPA를 사용할 때 항상 거론되는 문제가 있다. 면접 질문에서도 매번 등장하는 `N+1` 문제다.

정의만 보면 N+1 문제는 다음 문장으로 설명할 수 있다.
> 1개의 쿼리를 예상했으나, 불필요한 쿼리 N 개가 더해져 총 N+1 개의 쿼리가 실행되는 문제

데이터베이스에 직접 SQL 쿼리를 날리는 것이 아니라, ORM 기술을 이용해 SQL 쿼리문을 자동으로 날리면서 생기는 문제다.

JPA의 경우 한 객체를 조회할 때 해당 객체와 연관된(매핑) 다른 객체들까지 함께 조회되는 경우 N+1 문제가 발생하게 된다.

---

다음과 같은 테이블이 있다고 가정해보자.
- 한 명의 유저는 여러 개의 게시글을 작성할 수 있다.
- 1 : N 연관 관계

| USER |
|-----------|
| id |
| name |

| ARTICLE |
|-----------|
| id |
| content |
| title |


💻 이를 자바 코드로 작성하면 다음과 같을 것이다.

- User

```java
@Entity
public class User {
	@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column
    private String name;
    
    @OneToMany(mappedBy = "user")
    private Set<Article> articles = emptySet();
```

- Article

```java
@Entity
public class Article {
	@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column
    private String content;
    
    @Column
    private String title;
    
    @ManyToOne
    private User user;
```

---

<h1 id=2>2️⃣ 즉시로딩</h1>

먼저 `즉시 로딩`에 대해 살펴보자.
즉시 로딩은 많은 강의에서 강조하지만, 실무에서 쓰지 말아야 할(자제) 모든 문제의 근원이 되는 로딩 방식이다.

❌(반드시 사용하지 말아야 하는 것은 아니다. 간단한 연관 관계의 경우 즉시 로딩을 사용하는 것이 오히려 성능 면에서 좋을 때도 있다)

```java
@OneToMany(mappedBy = "user", fetch = FetchType.EAGER)
private Set<Article> articles = emptySet();
```

```java
@ManyToOne(fetch = FetchType.EAGER)
private User user;
```

그럼 `User` 입장에서 즉시 로딩을 사용한다고 했을 때 왜 문제가 되는 것일까?

```sql
SELECT user.name FROM USER
```
위와 같은 쿼리를 작성한다고 했을 때, JPA는 User의 필드인 Article 에 `EAGER`가 붙은 것을 보고, User를 가져올 때 해당 User와 연관된 `Article`도 함께 조인해 쿼리를 날린다.

> 즉, 모든 User를 검색하고 싶어 SELECT 쿼리 한 개를 보냈지만 - 1
즉시 로딩이 걸려있기 때문에 각각의 User가 가진 Article을 모두 검색 - N
하는 문제가 발생하는 것이다 - N+1

User의 수가 적으면 크게 문제가 되진 않겠지만, 만약 User의 수가 100명이고 한 유저당 10개의 게시글을 작성했다고 치면 1 + 1000 = 1001 개의 쿼리가 실행된다.

📝 즉시 로딩 문제를 정리하면 다음과 같다.
**'즉시 로딩은 연관된 객체에 대한 정보를 항상 가져오는 문제가 발생한다'
**

---

<h1 id=3>3️⃣ 지연로딩</h1>

이와 같이 모든 연관 객체를 즉시 불러오는 데서 오는 성능 문제를 피하기 위해 지연 로딩이 사용된다.

지연 로딩은 User를 조회했을 때 연관된 객체인 Article을 조회하지 않는다.

> JPA는 User를 조회할 때 User 객체 자체는 실제로 로딩되지만, 연관된 필드인 articles는 프록시 객체로 채워진다. **이 프록시에 실제 접근이 일어나면 그때 Article을 위한 쿼리가 실행된다**.

**🤔 그럼 지연 로딩을 사용하면 이제 N+1 문제가 모두 해결되는 것일까?
**

<br>

🚨그렇지 않다🚨

지연 로딩은 User 객체만 사용할 때는 조인을 사용하지 않아 성능 최적화를 해주지만, 결국 연관된 엔티티를 조회해야 하는 경우에는 조인을 통해 해당 객체를 불러와야 한다.

---

<h1 id=4>4️⃣ fetch join</h1>

N+1 문제의 근본적 이유는 `JPA의 연관관계 처리 방식`에서 비롯된다.

>따라서 JPA가 자동으로 수행하는 쿼리를 사용하지 않고, 직접 JPQL을 작성해 연관 객체를 모두 한 번에 불러올 수 있으면 문제를 해결할 수 있을 것 같다.

먼저 `fetch join` 을 사용하지 않는 `jpql` 코드를 보자.

- LAZY Loading 이라고 가정

```java
@Query("SELECT DISTINCT u FROM User u LEFT JOIN u.articles")
List<User> findAllJPQL();
```

해당 메서드가 호출되면 여전히 N+1 문제는 동일하게 발생한다.
아직까지는 지연 로딩이 User에 걸려있고, join을 했어도 프록시로 가져오는건 변함없기 때문이다.

이제 fetch join을 사용해보자.

```java
@Query("SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.articles")
List<User> findAllJPQLFetch();
```

> 이렇게 조인문에 fetch를 걸어주면, 지연로딩이 걸려있어도 연관 관계에 대해 즉시 로딩을 실행한다.

즉, article도 모두 한 번에 쿼리로 가져오기 때문에 N+1 문제가 발생하지 않는다.

**🤔 즉시로딩과 같은거 아닌가요?**

결과만 보면 즉시 로딩과 같아 보이지만, fetch join은 JPQL에서 명시적으로 쿼리를 작성한 경우에만 해당 연관 데이터를 로딩한다.

즉시 로딩은 모든 상황에서 무조건 연관 객체를 불러오지만, **fetch join은 필요할 때만 제어할 수 있어 더 유연하고 성능에도 이점**이 있다.

---

<h1 id=5>5️⃣ @EntityGraph</h1>

fetch join으로 N+1 문제를 해결했지만, `fetch join`은 하드 코딩되는 문제가 있다. 이를 최소화하고 싶으면 `@EntityGraph`를 사용하면 된다.

```java
@EntityGraph(arrtibutePaths = {"articles"}, type = EntityGrapthType.FETCH)
@Query("SELECT DISTICT u FROM User u LEFT JOIN u.articles")
List<User> findAllEntityGraph();
```

JPQL 구문에서의 fetch는 존재하지 않지만 fetch join과 동일한 쿼리를 실행한다.

**🔥 해치웠나?**
fetch join을 사용하면 이제 모든 문제가 해결된 것 같아 보이지만.. 
사용시 유의해야 할 케이스들이 있다.

그 중 두 가지를 알아보자.

<h2 id=6>✅ 1. Pagination</h2>
JPA에서 페이징 처리를 할 때 가장 많이 겪는 이슈다.
fetch join 으로 N+1 문제를 개선했지만 막상 Page를 반환하는 쿼리를 작성하면 다음과 같은 에러가 발생한다.

```java
@EntityGraph(attributePaths = {"articles"}, type = EntityGraphType.FETCH)
@Query("SELECT DISTINCT u FROM User u LEFT JOIN u.articles")
Page<User> findAllPage(Pageable pageable);
```

```java
@Test
void pagingFetchJoinTest() {
	PageRequest pageRequest = PageRequest.of(0,2);
    Page<User> users = userRepository.findAllPage(pageRequest);
    
    for(User user : users) {
    	System.out.prinln(user.articles.size());
    }
}
```
0페이지에 2명의 유저를 반환하는 `PageRequest` 객체를 파라미터로 전달했다.

💡**과연 쿼리가 하나만 나갈까**❓
- 실행된 쿼리
```mysql
Hibernate:
/* select
    distinct u
from
    User u
left join
    u.articles */ 
select
    distinct user0_.id as id1_1_0_,
    articles1_.id as id1_0_1_,
    user0_.name as name2_1_0_,
    articles1_.content as content2_0_1_,
    articles1_.title as title3_0_1_,
    articles1_.user_id as user_id4_0_1_,
    articles1_.user_id as user_id4_0_0__,
    articles1_.id as id1_0_0__
from
    users user0_
left outer join
    articles articles1_
        on user0_.id=articles1_.user_id
Hibernate:
/* select
    count(distinct u)
from
    User u
left join
    u.articles */ 
select
    count(distinct user0_.id) as col_0_0_
from
    users user0_
left outer join
    articles articles1_
        on user0_.id=articles1_.user_id
5
5
```

한 개의 쿼리가 실행되긴 했지만, MySQL에서 페이징을 처리할 때 사용하는 `Limit` 과 `Offset`은 실행되지 않았다.
분명 지정해줬는데도 말이다.
(Count 쿼리는 Page 반환 시 실행되는 쿼리므로 제외하고 생각)

```shell
WARN 79170 --- [    Test worker] o.h.h.internal.ast.QueryTranslatorImpl   : HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!
```
에러를 해석해보면 `collection fetch`에 대해서 paging 처리가 되었지만, 인메모리를 사용해 조인을 했다고 경고를 보여준다.


실제 날아간 쿼리와 이 경고를 통합해서 이해를 해보면 일단 List의 모든 값을 select해서 인메모리에 저장하고, application 단에서 필요한 페이지만큼 반환을 알아서 해주었다는 이야기가 된다.

이러면 우리는 사실상 Paging을 한 이유가 없어지는 것과 마찬가지다.
**100만건의 데이터가 있을 때 그 중 10건의 데이터만 paging하고 싶었으나 100만건을 다 가져온다? 그것도 메모리에?**
> **OOM(Out of Memory)이 발생할 확률이 매우 높다.**

따라서 Pagination에서는 fetch join을 사용하더라도 문제가 있다.

### 📌fetch join 과 @OneToMany 페이징 에러 정리

- fetch join으로 `@OneToMany` 관계를 조인하면, 유저가 1명인데 게시물이 3개면 중복 row가 생긴다.
- JPA는 이런 중복을 제거하기 위해 `distinct`를 사용하지만,
- DB 단에서 중복을 제거한 후에 페이징 처리를 같이 하는 게 어렵기 때문에,
- 하이버네이트는 그냥 데이터를 다 조회한 후 애플리케이션에서 처리하는 쪽을 선택한거다.

---
## ✅페이징 처리시 인메모리 사용 문제 해결 방법

### ☑️1. xToOne 관계에서 페이징 처리
`~ToOne` 관계라면 페이징 처리를 진행해도 괜찮다.
```java
@EntityGraph(attributePaths = {"user"}, type = EntityGraphType.FETCH)
@Query("SELECT a FROM Article a LEFT JOIN a.user")
Page<Article> findAllPage(Pageable pageable);
```

- Article은 User에 대해 `ManyToOne` 연관관계이기 때문에 지금처럼 페이징을 진행하다고 해도 인 메모리에서 모든 Article을 조회하는 것이 아니라, `limit`을 걸어 필요한 데이터만 가져올 수 있다.

```shell
Hibernate:
/* select
    a
from
    Article a
left join
    a.user */ 
select
    article0_.id as id1_0_0_,
    user1_.id as id1_1_1_,
    article0_.content as content2_0_0_,
    article0_.title as title3_0_0_,
    article0_.user_id as user_id4_0_0_,
    user1_.name as name2_1_1_
from
    articles article0_
left outer join
    users user1_
        on article0_.user_id = user1_.id
limit ?

```

### ☑️2. Batch Size
`~ToMany` 관계, 즉 컬렉션 조인을 했을 경우 Many 쪽 객체들이 One에 매핑되어 fetch join 된다면 `Pagination`에서 갯수를 판단하기 어렵기 때문에 임의로 인메모리에서 수행한다고 했다.

따라서 컬렉션 조인을 하는 경우에는 fetch join을 사용하지 않고 조회할 컬렉션 필드에 대해 `@BetchSize`를 걸어 해결해야 한다.(할 수 있다)

```java
@BatchSize(size = 100)
@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
private Set<Article> articles = emptySet();
```

배치 사이즈를 적용하면 articles만 따로 한 번에 SELECT 하게 된다.
처음 지연 로딩의 기본 설정 + 페이징 처리는 어떻게 되는지 확인해보자.

```shell
Hibernate:
/* select
    generatedAlias0
from
    User as generatedAlias0 */ 
select
    user0_.id as id1_1_,
    user0_.name as name2_1_
from
    users user0_ 
limit ?

Hibernate:
/* select
    count(generatedAlias0)
from
    User as generatedAlias0 */ 
select
    count(user0_.id) as col_0_0_
from
    users user0_

== find all ==
Hibernate:
/* load one-to-many com.example.jpa.domain.User.articles */ 
select
    articles0_.user_id as user_id4_0_1_,
    articles0_.id as id1_0_1_,
    articles0_.id as id1_0_0_,
    articles0_.content as content2_0_0_,
    articles0_.title as title3_0_0_,
    articles0_.user_id as user_id4_0_0_
from
    articles articles0_
where
    articles0_.user_id in (
        ?, ?
    )

```

User 에 대해 limit 쿼리가 나갔으므로 인메모리가 아닌 정상 페이징 처리가 동작한 것 같다.
근데 밑에 article을 SELECT 하는 쿼리가 새로 등장했다.

> 이는 지연 로딩하는 객체에 대해 배치성 로딩을 하는 것이라 생각하면 된다.

기존의 지연로딩에 대해서는 객체를 조회할 때 그때마다 쿼리문을 날려 N+1 문제가 발생했는데, 객체를 조회하는 시점에 쿼리를 하나만 날리는게 아니라 해당하는 Article에 대해 쿼리를 batch size 만큼 날리는 거다.

⚠️ 다만 배치 사이즈는 연관관계에서의 데이터 사이즈를 확실하게 알 수 있다면 최적화된 size를 구할 수 있겠지만, 일반적으로 그 사이즈를 알긴 어렵기 때문에 대충 100~1000개 사이를 사용한다는 것을 유념하고 사용해야 한다.

### ☑️3. @Fetch(FetchMod.SUBSELECT)
`@BatchSize`와 비슷하지만 다른 애노테이션이다.

> 배치 사이즈는 페이징 시 사이즈 수를 제한해 사용자가 최적화된 데이터 사이즈를 적용하게끔 도와준다면, `@Fetch`는 그냥 전부 다 해준다.

```java
@Fetch(FetchMode.SUBSELECT)
@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
private Set<Article> articles = emtpySet();
```

```shell
Hibernate:
/* load one-to-many com.example.jpa.domain.User.articles */ 
select
    articles0_.user_id as user_id4_0_1_,
    articles0_.id as id1_0_1_,
    articles0_.id as id1_0_0_,
    articles0_.content as content2_0_0_,
    articles0_.title as title3_0_0_,
    articles0_.user_id as user_id4_0_0_
from
    articles articles0_
where
    articles0_.user_id in (
        select
            user0_.id
        from
            users user0_
    )

```
다른 부분은 배치 사이즈와 동일하다. Collection을 따로 조회하는 쿼리만 가져왔다.

**쿼리를 보면 WHERE 절 안에 IN 문에서 현재 SELECT 할 User의 아이디가 들어가 있어야 하는데, User를 그냥 싹 다 조회하는 SELECT ALL 쿼리가 실행된 것을 볼 수 있다.
**
즉, `@BatchSize`의 경우 주어진 size 만큼 User id를 입력하여 그때 프록시 상태에 따라 지연 로딩을 한다면,

`@Fetch`는 그런거 없이 User Id를 싹 다 조회한다.
- 마치 `@BatchSize(size = 무한)` 처럼 동작하는 것.

⚠️ **이 부분은 성능적 테스트가 필요하며 사실 잘 사용되지는 않는다.**

---

<h2 id=7>✅ 2. Collection fetch join 불가</h2>

> 둘 이상의 컬렉션 페치 조인(`~ToMany`)은 불가능하다.

fetch join은 batch size에서 설명한대로 하나의 컬렉션 페치 조인에 대해 인메모리에서 모든 값을 가져오기 때문에 페이징이 불가능했다.

fetch join을 할 때 ToMany의 경우 한 번에 fetch join을 가져오기 때문에 collection join이 2개 이상이 될 경우 매우 많은 값이 메모리에 로드돼 예외가 발생한다.

이때 발생하는 예외가 `MultipleBagFetchExcetpion` 이다.

한번 코드로 보자.
```java
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 10, nullable = false)
    private String name;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Article> articles = new ArrayList<>();

    @OneToMany(mappedBy = "question", fetch = FetchType.LAZY)
    private List<Question> questions = new ArrayList<>();
```
당연히 User만 조회하면 지연로딩으로 인해 아무런 문제가 발생하지 않는다.

다만, articles나 questions을 조회해야 하는 상황이라면 N+1 이 발생할 것이다.

이를 fetch join으로 해결하는 코드를 보자.(해결은 안되지만)

```java
@EntityGraph(attributePaths = {"articles", "questions"}, type = EntityGraphType.FETCH)
@Query("select distinct u from User u left join u.articles")
List<User> findAllEntityGraph2();
```

```java
@Test
void collectionFetchJoinTest() {
	List<User> users = userRepository.findAllEntityGraph2();
}
```

- 예외 발생
```java

org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [com.example.jpa.domain.User.articles, com.example.jpa.domain.User.questions]; nested exception is java.lang.IllegalArgumentException: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [com.example.jpa.domain.User.articles, com.example.jpa.domain.User.questions]
```

> `ToOne` 페치 조인은 얼마든지 해도 아무 문제 없지만, `ToMany` 는 하나 일 때 `인메모리`, 두 개 부터 `Exception` 으로 처리한다.


🤔**그럼 어떻게 해결하나❓**


### ☑️ BatchSize
배치 사이즈는 `Pagination`의 해결책으로 제시된 방법이기도 하지만 `Collection join`이 두 개 이상일 때 발생하는 `MultipleBagFetchException` 을 해결할 수도 있다.

리스트 자료구조를 사용해야 하거나, Set을 사용한다고 해서 인메모리 로딩을 막을 수 없기 때문에 2개 이상의 컬렉션 조인을 사용하는데 Pagitation을 사용해야 할 경우도 인메모리를 사용하지 않고 사용할 수 있다.

SET, LIST 위에 `@BatchSize`를 걸면 동일하게 인메모리에서 가져오지 않고 호출하는 당시에 한 번에 모든 데이터를 가져온다.

```java
@BatchSize(size = 100)
@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
private Set<Article> articles = emptySet();

@BatchSize(size = 100)
@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
private Set<Question> questions = emptySet();
```

```java

@Query("select distinct u from User u left join u.articles left join u.questions")
Page<User> findAllPage2(Pageable pageable);
```
> ⚠️주의
batch size에 fetch join을 사용하면 안된다.
fetch join이 우선 적용되기 때문에 배치 사이즈는 무시되고 인메모리로 가져온다

---
<h1 id=8>정리</h1>

1. 즉시로딩 : 쓰지마라
2. 지연로딩 : 지연로딩시 N+1 문제 그대로 존재한다.
3. fetch join : 지연로딩의 N+1 해결책
4. collection join : fetch join과 페이징 처리 시 인메모리 문제 발생
5. 2개 이상의 collection join : BatchSize 써라 (join fetch랑 batch size 같이 쓰지 마라)

