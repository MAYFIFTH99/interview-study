# 1. 기존 SQL의 문제점

Native 쿼리를 사용할 때는 단순 CRUD 작업을 위해서 DB 커넥션을 생성하고, `PreparedStatment` SQL을 작성한 뒤 `SetXxx`으로 파라미터를 대입하고, `Resultset` 으로 결과를 받아오고, 커넥션을 반환하고, 에러 처리를 하는 등 동일한 코드를 무한 반복해야 하는 문제가 있다.

이러한 코드들이 분산되어 위치하기 때문에 한 번에 메서드로 빼서 해결하는 것도 쉽지 않다.
(억지로 템플릿 메서드 패턴을 이용하면 가능하긴 하다.)

이러한 보일러 코드를 없애고, 정말 필요한 로직만 작성할 수 있다면 개발자의 생산성이 얼마나 높이질까?

JPA를 사용하면 이러한 중복 코드 작성 없이 빠르게 데이터베이스에 접근하고 작업을 수행할 수 있다.


---

# 2. OOP와 RDBMS 간 패러다임 불일치

객체를 DB에 넣을 때, 객체와 관계형 DB의 데이터 간 차이점이 존재한다.

RDBMS에는 상속이란 개념도 없고, JAVA는 참조를 통해 다른 객체에 접근하지만, RDBMS는 외래 키를 이용해 다른 테이블에 접근한다.

JPA는 연관 관계, Table 슈퍼타입 서브타입 관계 등을 이용해 이러한 패러다임 불일치 문제를 최소화 시키고 문제 없이 동작하도록 설계되었다.



---

# 3. SQL 데이터베이스 종속성

만약 SELECT, UPDATE, DELETE 같은 쿼리가 이미 작성되어 있는데, 테이블에 Column이 하나 추가되었다고 가정하자.

그러면 기존에 작성했던 쿼리들을 모두 수정하고, 테이블에도 열을 추가하는 등 유지보수하기가 매우 어려워지고 에러 발생 가능성도 높아진다.

JPA를 사용하면 컬럼이 추가된 경우, 단순히 객체에 필드를 하나 추가해주기만 하면 자동으로 DDL을 생성하기 때문에 매우 깔끔하고 편하게 관리할 수 있다.

또, 기존에 MySQL을 사용하다가 Oracle SQL로 변경해야 하는 경우 특정 벤더사에서만 제공하는 기능을 사용하는 쿼리가 존재한다면, 이를 모두 이전하는 벤더사의 쿼리로 수정해야 하는 벤더 종속성 문제도 있다.

JPA는 Dialect를 설정하면 해당 벤더 사에 맞는 쿼리를 자동 생성해서 실행한다.

- JPA 구현체인 하이버네이트가 DB 벤더에 맞는 SQL을 자동으로 생성한다.

> JPA를 사용하면 1차적으로 JPQL을 자동으로 생성하고, 그 다음 하이버네이트 같은 JPA 구현체가 해당 벤더사에 맞는 SQL로 변환해서 실행해준다.
