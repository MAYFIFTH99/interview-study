# 1. 기존 SQL의 문제점

Native 쿼리를 사용할 때는 단순 CRUD 작업을 위해서 DB 커넥션을 생성하고, `PreparedStatement` SQL을 작성한 뒤 `SetXxx`으로 파라미터를 대입하고, `Resultset` 으로 결과를 받아오고, 커넥션을 반환하고, 에러 처리를 하는 등 동일한 코드를 무한 반복해야 하는 문제가 있다.

이러한 코드들이 분산되어 위치하기 때문에 한 번에 메서드로 빼서 해결하는 것도 쉽지 않다.
(억지로 템플릿 메서드 패턴을 이용하면 가능하긴 하다.)

이러한 보일러 코드를 없애고, 정말 필요한 로직만 작성할 수 있다면 개발자의 생산성이 얼마나 높이질까?

JPA를 사용하면 이러한 중복 코드 작성 없이 빠르게 데이터베이스에 접근하고 작업을 수행할 수 있다.


---

# 2. OOP와 RDBMS 간 패러다임 불일치

객체를 DB에 넣을 때, 객체와 관계형 DB의 데이터 간 차이점이 존재한다.

RDBMS에는 상속이란 개념도 없고, JAVA는 참조를 통해 다른 객체에 접근하지만, RDBMS는 외래 키를 이용해 다른 테이블에 접근한다.

JPA는 연관 관계, Table 슈퍼타입 서브타입 관계 등을 이용해 이러한 패러다임 불일치 문제를 최소화 시키고 문제 없이 동작하도록 설계되었다.



---

# 3. SQL 데이터베이스 종속성

만약 SELECT, UPDATE, DELETE 같은 쿼리가 이미 작성되어 있는데, 테이블에 Column이 하나 추가되었다고 가정하자.

그러면 기존에 작성했던 쿼리들을 모두 수정하고, 테이블에도 열을 추가하는 등 유지보수하기가 매우 어려워지고 에러 발생 가능성도 높아진다.

JPA를 사용하면 컬럼이 추가된 경우, 단순히 객체에 필드를 하나 추가해주기만 하면 자동으로 DDL을 생성하기 때문에 매우 깔끔하고 편하게 관리할 수 있다.

또, 기존에 MySQL을 사용하다가 Oracle SQL로 변경해야 하는 경우 특정 벤더사에서만 제공하는 기능을 사용하는 쿼리가 존재한다면, 이를 모두 이전하는 벤더사의 쿼리로 수정해야 하는 벤더 종속성 문제도 있다.

JPA는 Dialect를 설정하면 해당 벤더 사에 맞는 쿼리를 자동 생성해서 실행한다.

- JPA 구현체인 하이버네이트가 DB 벤더에 맞는 SQL을 자동으로 생성한다.

> JPA를 사용하면 1차적으로 JPQL을 자동으로 생성하고, 그 다음 하이버네이트 같은 JPA 구현체가 해당 벤더사에 맞는 SQL로 변환해서 실행해준다.


---

# 4. 성능 최적화

JPA는 애플리케이션과 데이터베이스 사이에서 성능 최적화 기회를 제공한다.

같은 트랜잭션 안에서는 영속성 컨텍스트가 동일한 엔티티를 반환하기 때문에, 데이터베이스와 통신하는 횟수를 줄여 속도를 높일 수 있다.

또, 데이터 변경 사항을 그때 그때마다 DB에 반영해 커넥션을 낭비하지 않고, 쓰기 지연 저장소에 해당 SQL 문들을 모아둔 뒤, 마지막 커밋 시점에 한 번에 수행함으로써 내부적으로 성능을 최적화 한다.

이외에도 객체의 상태를 추적하는 영속성 컨텍스트를 통해 `변경 감지`, `1차 캐시`, `트랜잭션 관리` 등의 기능도 제공해 객체 지향적 개발을 지원한다.

또 `QueryDsl`과 같은 오픈 소스와 병행하여 사용하면 기존 문자열 기반 쿼리에서 생기는 타입 불안정성을 컴파일 시점에 체크할 수 있고, 동적 쿼리를 매우 쉽게 처리할 수 있다는 장점이 있다.


---

# 정리

요약하자면, JPA는 객체 지향적인 프로그래밍을 유지하면서도 데이터베이스와의 복잡한 상호작용을 추상화하여,

- 생산성 향상
- 유지보수성 증가
- DB 독립성 확보
- 패러다임 불일치 해결

이라는 여러 이점을 제공하기 때문에, 레거시 프로젝트가 아닌 경우 대부분 채택되어 사용되고 있다.

> 그렇다고 JPA가 만능은 아니다.
매우 복잡한 쿼리를 사용해야 하거나, 집계/통계 쿼리 비중이 많고, 수동적 제어권을 갖고 세부 사항을 조절해야 하는 경우 MyBatis같은 다른 ORM 기술이나, Native Query를 사용하는 경우도 많다.
